---
title: "データの読み書き"
---

```{r}
#| include: false
library(tidyverse)
here::here("data") |> dir.create()
```


データ分析の最初のステップは、分析したいデータをRに読み込むことです。
`readr` は `tidyverse` の一部で、CSV ファイルのような「長方形」のテキストデータを R に高速かつ正確に読み込むためのパッケージです。

**Base R** にも `read.csv()` という関数がありますが、`readr` を使うことには以下のようなメリットがあります。

- 高速である
- 読み込み中に進捗バーが表示される
- 文字列を自動でファクター型に変換しない
- より賢く列の型を推測してくれる

## `read_csv()`・`write_csv()`: CSVファイルの読み書き

最もよく使われるのが `read_csv()` 関数です。
これは、カンマ区切り（Comma Separated Values）のファイルを読み込み、`tibble` という `tidyverse` で使われるデータ形式に変換します。

まずは `tidyverse` を読み込みます。
```{r}
#| eval: false
library(tidyverse)
```

**基本的な使い方**

使い方は非常にシンプルで、ファイルへのパス（場所）を引数として渡すだけです。

```{r}
# 例として、まず R のデータフレームをCSVファイルとして書き出してみます
sample_data <- tibble(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie"),
  score = c(85.5, 92.0, 78.5)
)
```

CSV を書き込むには、`write_csv()` を使います。

```{r}
# 書き出したい tibble と書き込みたいパスとファイル名を渡します
write_csv(sample_data, "my_sample_data.csv")
```

CSV のを読み込むには、`read_csv()` を使います。

```{r}
# 今書き出したCSVファイルを読み込む
df <- read_csv("my_sample_data.csv")

# 読み込んだ結果を確認
df
```

`read_csv()` を実行すると、各列がどのデータ型（chr, dbl, int など）として認識されたかがコンソールに表示されます。

::: {.callout-note}
## ファイルパスの問題

Rスクリプトで `read_csv("data/my_sample_data.csv")` のようにファイルパスを指定すると、そのスクリプトを誰かと共有したり、別のPCで実行したり、ファイルの場所を移動したりした際に、パスが通らなくなりエラーが頻発します。

これは、Rがどのフォルダを基準にファイルを探しているか（ワーキングディレクトリ）が、実行環境によって変わってしまうためです。この問題を解決するために `setwd("C:/Users/...")` のようにワーキングディレクトリを固定する方法もありますが、これは他の人のPCでは動かないため、悪い習慣とされています。

## `here::here()` がすべてを解決

`here` パッケージは、この問題をシンプルかつエレガントに解決します。

メリット:

- `setwd()` が不要になる: `setwd()` をスクリプトの冒頭に書く必要が一切なくなります。
- どこでも動く: あなたの PC でも、同僚のPCでも、サーバー上でも、スクリプトを移動しても、同じコードがエラーなく動きます。
- 共同作業が楽になる: **Git** などでプロジェクトを共有する際に、ファイルパスの違いを気にする必要がありません。
- 直感的: プロジェクトのルート（一番上の階層）を基準にパスを組み立てるため、非常に分かりやすいです。

`hereの仕組み`: `here` は、現在のスクリプトの場所から上の階層に向かって `.Rproj` ファイルや `.git` フォルダを探します。それらが見つかった場所を「プロジェクトのルート」と判断し、そこを基準点としてファイルへの絶対パスを安全に構築してくれるのです。
:::

### `here::here()` の使い方

`here()` を使うための最も重要な前提は、作業を `RStudioプロジェクト` (`.Rproj` ファイル) で管理することです。

まだインストールしていない場合は、一度だけコンソールで実行します。

```{r}
#| eval: false
install.packages("here")
```

では、ファイルパスを組み立てましょう。

`here("フォルダ名", "ファイル名")` のように、プロジェクトのルートからの道のりをカンマで区切って指定します。


```{r}
filename <- here::here("data", "my_sample_data.csv")
write_csv(sample_data, filename)
df <- read_csv(filename)
df
```

:::{.callout-ntoe}

`::` は、特定のパッケージに属する関数を直接指定して呼び出すための演算子です。
`here::here() `は、「`here` という名前のパッケージの中にある `here` という名前の関数」という意味になります。

なぜ `::` を使うのか？

`::` を使うことには、主に2つの大きなメリットがあります。

1. 関数の名前の衝突（競合）を避ける

Rでは、異なるパッケージが同じ名前の関数を持っていることがあります。
例えば、`dplyr` パッケージとRの基本機能（`stats` パッケージ）は、どちらも `filter()` という名前の関数を持っています。

もし `library(dplyr) `を実行せずに `filter()` を使うと、意図せず基本機能の `filter()` が動いてしまうかもしれません。`dplyr::filter()` と書けば、「`dplyr` の `filter()` を使います」と明示的に宣言できるため、このような混乱やエラーを防げます。

2. コードの可読性が上がる

`here::here()` と書かれているコードを見れば、誰でも「ああ、これは `here` パッケージの機能を使っているんだな」と一目で分かります。`library()` で一度にたくさんのパッケージを読み込むと、どの関数がどのパッケージ由来なのか分かりにくくなることがあります。
:::


## `read_tsv()`: TSVファイルを読み込む

`read_tsv()` は、タブ区切り（Tab Separated Values）のファイルを読み込むための関数です。
基本的な使い方は `read_csv()` と全く同じです。

```{r}
filename = here::here("data", "my_sample_data.tsv")
# タブ区切りのファイルを作成
write_tsv(sample_data, filename)

# TSVファイルを読み込む
df_tsv <- read_tsv(filename)
df_tsv
```

## `read_delim()`: 一般的な区切り文字ファイル

もしあなたのデータがカンマやタブではなく、セミコロン(;)やパイプ(|)のような特殊な文字で区切られている場合は、`read_delim()` を使います。
`delim` 引数で区切り文字を指定します。

```{r}
filename = here::here("data", "my_sample_data.txt")

# セミコロン区切りのファイルを作成
write_delim(sample_data, filename, delim = ";")

# セミコロン区切りのファイルを読み込む
df_delim <- read_delim(filename, delim = ";")
df_delim
```

**列の型を自分で指定する**

`readr` は賢く列の型を推測してくれますが、時々間違えることもあります（例：数値のはずが文字列として読み込まれる）。
その場合は `col_types` 引数を使って、正しい型を手動で指定できます。

`cols()` 関数の中に、列ごとに型を指定します。

- `col_character()`: 文字列型
- `col_integer()`: 整数型
- `col_double()`: 小数を含む数値型
- `col_logical()`: 論理値型 (`TRUE/FALSE`)

例: `id` を文字列として、`score` を整数として読み込んでみる

```{r}
filename = here::here("data", "my_sample_data.csv")

df_manual <- read_csv(
  filename,
  col_types = cols(
    id = col_character(),
    score = col_integer()
  )
)

df_manual
```

