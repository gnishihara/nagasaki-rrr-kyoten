{
  "hash": "4b47bb32376d094f08b8f3e6864c7969",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"ベクトル・行列などの作り方\"\n---\n\nこれまでは、一つの値を一つのオブジェクトに格納する方法を学びました。しかし、実際のデータ分析では、複数の値をまとめて扱いたい場面がほとんどです。ここでは、そのための基本的な3つのデータ構造、ベクトル、リスト、行列を学びましょう。\n\n## ベクトル (Vector)\n\nベクトルは、Rにおける最も基本的なデータ構造です。\n同じ種類のデータ（例：すべて数値、すべて文字）を一直線に並べたものです。\n\nベクトルを作成するには、`c()` という関数を使います。\n`c` は \"combine\" (組み合わせる) の略です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 数値のベクトルを作成\nnumeric_vector <- c(10, 20, 30, 40, 50)\nnumeric_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40 50\n```\n\n\n:::\n\n```{.r .cell-code}\n# 文字列のベクトルを作成 (文字列は \"\" または '' で囲む)\ncharacter_vector <- c(\"apple\", \"banana\", \"cherry\")\ncharacter_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"cherry\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 論理値 (TRUE/FALSE) のベクトルを作成\nlogical_vector <- c(TRUE, FALSE, TRUE, TRUE)\nlogical_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n**ベクトルの特徴：**\n\n同じデータ型の要素しか含めることができません。\nもし異なる型のデータを混ぜると、Rが自動的に型を変換します（例：数値と文字を混ぜると、すべて文字に変換されます）。\n\n### ベクトルに対する操作\n\nベクトル全体に対して一度に計算を行うことができます。\nこれをベクトル化演算と呼び、Rの強力な特徴の一つです。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# numeric_vector の各要素を2倍する\nnumeric_vector * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  20  40  60  80 100\n```\n\n\n:::\n\n```{.r .cell-code}\n# numeric_vector の各要素に5を足す\nnumeric_vector + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 25 35 45 55\n```\n\n\n:::\n:::\n\n\n\n## リスト (List) ️\n\nリストは、ベクトルとは異なり、異なる種類のデータを一つのオブジェクトに格納できる、より柔軟なデータ構造です。\nまるで、色々な種類の品物を入れられるショッピングカートのようです。\n\nリストを作成するには、`list()` 関数を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 数値、文字列、ベクトルを混在させたリストを作成\nmy_list <- list(\n  name = \"Taro\",      # 文字列\n  age = 30,           # 数値\n  scores = c(85, 92, 78), # ベクトル\n  is_student = TRUE   # 論理値\n)\n\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"Taro\"\n\n$age\n[1] 30\n\n$scores\n[1] 85 92 78\n\n$is_student\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n**リストの特徴：**\n\n数値、文字列、ベクトル、さらには他のリストなど、何でも格納できます。\n\n= を使って各要素に名前をつけることができます（例：`name = \"Taro\"`）。\n\n## リストの要素へのアクセス\n\nリストの特定の要素を取り出すには、`$` または `[[ ]]` を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# `$` を使って \"name\" 要素にアクセス\nmy_list$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Taro\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# `[[ ]]` を使って \"scores\" 要素にアクセス\nmy_list[[\"scores\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 85 92 78\n```\n\n\n:::\n:::\n\n\n## 行列 (Matrix)\n\n行列（マトリックス）は、ベクトルを2次元（行と列）に拡張したものです。スプレッドシートの表のように、データを行と列の形式で扱います。\n\n行列を作成するには、`matrix()` 関数を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1から6までの数値を使って、2行3列の行列を作成\nmy_matrix <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n**行列の特徴：**\n\nベクトルと同様に、すべての要素が同じデータ型でなければなりません。\n\n`nrow` で行数を、`ncol` で列数を指定します。\n\n## 行列の要素へのアクセス\n\n行列の要素には、`[行番号, 列番号]` という形式でアクセスします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2行目の3列目の要素にアクセス\nmy_matrix[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# 1行目のすべての要素にアクセス (列番号を空にする)\nmy_matrix[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2列目のすべての要素にアクセス (行番号を空にする)\nmy_matrix[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\n## 配列 (Array)\n\n配列は、同じ種類のデータを3次元以上の構造で格納するためのオブジェクトです。行列がスプレッドシート1枚だとすれば、配列はそのスプレッドシートを何枚も重ねた「束」や「キューブ」のようなものだとイメージしてください。\n\n配列を作成するには、array() 関数を使います。\n\n```r\narray(データ, dim = c(行数, 列数, 次元数, ...))\n```\n\ndim (dimensionsの略) 引数に、各次元の大きさをベクトルで指定するのがポイントです。\n\n2つの「3行2列」の行列を重ねた、3次元の配列を作成してみましょう。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1から12までの数値データを用意\ndata_vector <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\n\n# 3行 x 2列 x 2面 の配列を作成\nmy_array <- array(data_vector, dim = c(3, 2, 2))\n\nmy_array\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n```\n\n\n:::\n:::\n\n\n実行すると、コンソールには2つの3x2行列が表示されます。これが dim = c(3, 2, 2) の意味するところです。\n\n**配列の特徴：**\n\n行列と同様に、すべての要素が同じデータ型でなければなりません。\n\n`dim` を指定することで、2次元、3次元、4次元…と自由に次元を定義できます。\n\n## 配列の要素へのアクセス\n\n配列の要素へのアクセスは、行列の `[行, 列]` という指定をさらに拡張した形で行います。3次元配列の場合は `[行番号, 列番号, 面番号]` のようになります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1番目の面の、3行目の2列目の要素にアクセス\nmy_array[3, 2, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2番目の面の、すべての要素（つまり2番目の行列全体）にアクセス\nmy_array[, , 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n```\n\n\n:::\n\n```{.r .cell-code}\n# すべての面の、1行目のすべての列にアクセス\nmy_array[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    7\n[2,]    4   10\n```\n\n\n:::\n:::\n\n\n\n## まとめ\n\n- ベクトル：同じ型のデータを1次元に並べたもの\t`c()`\n- リスト：異なる型のデータを格納できるもの\t`list()`\n- 行列：同じ型のデータを2次元（行と列）に並べたもの\t`matrix()`\n- 配列: 同じ型のデータを `N` 次元に並べたもの `array()`\n\n\n## 演習\n\n1. あなたの好きな3つの果物の名前を要素に持つ、`favorite_fruits` という名前のベクトルを作成してください。\n2. `name`（あなたの名前）、`height`（あなたの身長(cm)）、`favorite_number`（好きな数字）という3つの要素を持つ `my_profile` という名前のリストを作成してください。\n3. `1`から`9`までの連続した整数を使って、3行3列の行列 `nine_matrix` を作成してください。\n4. `1`から`27`までの連続した整数を使って、3行3列の行列が3つ重なった構造の3次元配列 `cube_array` を作成してください。\n5. 作成した `cube_array` の3番目の行列（面）だけを取り出して表示してください。\n6. `cube_array` の1番目の行列（面）の、2行目、2列目にある要素は何ですか？コードを書いて確認してみましょう。",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}